clear; clc; close all;

% Parameter settings
dt = 0.5; T = 200; N = round(T/dt);
v0 = 2; kappa = 0.5;
omega = 1/(6*pi); beta = 1/(pi); sigx = 1; sigy = sigx; sigv = 1;

lambda = 0; % Bias strength


M = 50;  % Number of realizations

x  = zeros(N,M);
y  = zeros(N,M);
th = zeros(N,M);
v  = zeros(N,M);

for i = 1:M
    % Reset random number stream each time (ensure trajectories are independent)
    rng('shuffle');

    % Randomize initial conditions
    % Initial conditions x(1,i) = 0; y(1,i) = 0; th(1,i) = 0; v(1,i) = v0;
    % Simulation loop
    for k=1:N-1
        % Bias field U
        U = @(X,Y) (2 - sqrt(X.^2 + Y.^2)) ./ (2 + sqrt(X.^2 + Y.^2));
        eps = 1e-10;
        Ux = (U(x(k)+eps,y(k))-U(x(k)-eps,y(k)))/(2*eps);
        Uy = (U(x(k),y(k)+eps)-U(x(k),y(k)-eps))/(2*eps);
        tperp = [-sin(th(k)), cos(th(k))];

        grad_norm = sqrt(Ux^2 + Uy^2) + 1e-6;   % Prevent division by zero
        proj = (tperp(1)*Ux + tperp(2)*Uy) / grad_norm;  % Normalized directional projection
        bias = lambda * proj;   % lambda controls range [-1,1]

        % Update heading
        th(k+1,i) = th(k,i) + (omega + bias)*dt + beta*sqrt(dt)*randn;
        % Update speed
        v(k+1,i) = v(k,i) - kappa*(v(k,i)-v0)*dt + sigv*sqrt(dt)*randn;
        % Update position
        x(k+1,i) = x(k,i) + v(k+1,i)*cos(th(k+1,i))*dt + sigx*sqrt(dt)*randn;
        y(k+1,i) = y(k,i) + v(k+1,i)*sin(th(k+1,i))*dt + sigy*sqrt(dt)*randn;
    end

end

% Plot trajectories
figure; hold on;
for i=1:M
    plot(x(:,i), y(:,i),'LineWidth',3);
end

set(gca, 'FontName', 'Times New Roman', 'FontSize', 16);
plot(x(1),y(1),'go','MarkerSize',20,'LineWidth',2);
plot(x(end,1:M),y(end,1:M),'rx','MarkerSize',20,'LineWidth',2);
title('Sample: circling phenomenon');
xlabel('X','FontSize', 16,'FontName', 'Times New Roman'); ylabel('Y','FontSize', 16,'FontName', 'Times New Roman'); axis equal;
xlim([-200 200]);  
ylim([-200 200]);
% Save results
save('traj1_1.mat','x','y','th','v','dt');

%% loop_stats.m
% Read the trajectories generated by simulate_circling_SDE.m and compute loop metrics
clear; clc;

M=50;

crossings1=[];
L1=[];
NT1=[];

for i = 1:1

    load(['traj1_',num2str(i),'.mat']); % containing x, y, dt
    X=x;
    Y=y;


for m = 1:size(x,2)


        x = X(:,m);
        y = Y(:,m);

x = (x - min(x(:))) / (max(x(:)) - min(x(:)));
y = (y - min(y(:))) / (max(y(:)) - min(y(:)));

n = numel(x);
crossings = 0; lengths = [];

% Path length function
path_length = @(X,Y) sum(sqrt(diff(X).^2 + diff(Y).^2));

for i=1:n-3
    for j=i+2:n-1
        % Line segment intersection detection
        [isC,~] = seg_intersect([x(i) y(i)], [x(i+1) y(i+1)], ...
                                 [x(j) y(j)], [x(j+1) y(j+1)]);
        if isC
            crossings = crossings + 1;
            lengths(end+1) = path_length(x(i:j),y(i:j));
        end
    end
end

L=path_length(x,y)/crossings;
% DR = sqrt((x(end)-x(1))^2 + (y(end)-y(1))^2 + eps)/path_length(x,y)/ ;


dx = diff(x);
dy = diff(y);
ds = sqrt(dx.^2 + dy.^2);      % Arc length
theta = atan2(dy, dx);         % Heading
dtheta = diff(theta);          % Turning angle increment
NT = sum(abs(dtheta)) / sum(ds);  % Normalized tortuosity
fprintf('Self-crossing number = %d\n', crossings);
fprintf('Average loop length = %d\n', L);
disp(['Normalized Tortuosity NT = ', num2str(NT)]);
lengths = rmoutliers(lengths);

        crossings_all(m) = crossings;
        crossings_mean=mean(crossings_all);
        L_all(m) = L;
        L_mean=mean(L);
        NT_all(m) = NT;
        NT_mean=mean(NT_all);


end
crossings1=[crossings1;crossings_mean];
L1=[L1;L_mean];
NT1=[NT1;NT_mean];
end

%% --- Utility function as script ---
function [isC, p] = seg_intersect(A,B,C,D)
% Determine whether AB and CD intersect
p = [];
den = (D(2)-C(2))*(B(1)-A(1)) - (D(1)-C(1))*(B(2)-A(2));
if abs(den) < 1e-12, isC=false; return; end
ua = ((D(1)-C(1))*(A(2)-C(2)) - (D(2)-C(2))*(A(1)-C(1)))/den;
ub = ((B(1)-A(1))*(A(2)-C(2)) - (B(2)-A(2))*(A(1)-C(1)))/den;
isC = (ua>=0 && ua<=1 && ub>=0 && ub<=1);
if isC
    p = A + ua*(B-A);
end
end
